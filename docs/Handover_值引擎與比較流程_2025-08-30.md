# Handover：值引擎、比較流程與運行說明（2025-08-30）

本文檔作為現狀交接（handover）與後續跟進的依據，對應專案根目錄 C:\\rovo\\watchdog_1 版本。

---

## 1. 目標與目前狀態（結論）
- 目標：以「快路徑」穩定讀取 Excel 值與公式，並即時顯示「有意義變更」。
- 目前狀態：
  - 值引擎已整合三路徑：`polars`（xlsx2csv+Polars）、`polars_xml`（內部 XML 解析）、`xml`（保守）。
  - 預設 `VALUE_ENGINE=polars_xml`，UI 亦可切換；runtime 也可覆蓋。
  - 當 `polars` 路徑無法提供非空值（provided=0），會自動 fallback 至 `polars_xml`，保證可讀到值。
  - 值引擎提供的值會寫入 `cached_value`，Phase 2 若已由值引擎提供即略過 `openpyxl data_only`，並列印統計。
  - 即時比較行為：on_modified 偵測到變更就「立刻顯示一次比較表」，之後再進入冷靜期與輪詢（已修正）。
  - 已修正 EmptyCell 例外（無 coordinate）導致的早退問題。

=> 就「是否成功以 polars 讀到值」：是，環境中 `xlsx2csv --list-sheets` 不相容（rc=2）時，系統會自動採用「按索引逐張抓取」；這是預期 fallback，並非錯誤。若 polars 提供值為 0，將自動轉用 polars_xml 確保讀值。

---

## 2. 架構與流程總覽
- 值引擎（Phase 1 / 快路徑）
  - polars：xlsx2csv -> CSV（記憶體/可持久化）-> Polars -> 寬轉長 -> 生成位址 A1…
    - 先嘗試 `--list-sheets`，不相容則列印診斷並改用 `-s i` 逐張抓取。
  - polars_xml：直接讀取 `xl/worksheets/sheetN.xml` + sharedStrings、inlineStr、boolean、數值，值保留原型別。
  - xml：保守讀取（舊版路徑）。
- 映射與組裝
  - 以工作表標題對齊；若名稱不一致，後備以索引對齊（有 `[value-engine] sheet name mismatch …` 訊息）。
  - 以列/行索引推導地址，避免 EmptyCell 無 `coordinate` 的例外。
  - 每張表會印 `[map] ws_index=… ws_title='…' -> key='…' provided=P keys=[…]`（最多 50 個樣本）。
- Phase 2（可選 / 值對齊）
  - 統計由值引擎提供的 cached_value 數量；若 `provided>0`，略過 `openpyxl data_only`，並印 `[phase2] provided_from_value_engine total=X per_sheet={…}`。
- 比較與渲染
  - 只顯示「有意義變更」：DIRECT_VALUE_CHANGE / FORMULA_CHANGE_INTERNAL / EXTERNAL_REF_LINK_CHANGE / EXTERNAL_REFRESH_UPDATE / CELL_ADDED / CELL_DELETED。
  - 隱藏 INDIRECT_CHANGE（`IGNORE_INDIRECT_CHANGES=True`）。

---

## 3. 診斷輸出（你會看到）
- 啟動：`[env] python=… | VALUE_ENGINE=… | CSV_PERSIST=… | sys.executable=…`
- 值引擎：`[value-engine] POLARS … | persist_csv=…` 或 `POLARS_XML …` / `XML parser …`
- polars 診斷（在 polars_reader）：`[polars-xlsx2csv] list rc=… names=… err=…`；若 list 失敗 -> `fallback brute-force by index 1..N`
- sheet 清單：`[value-engine] sheet keys from engine: ['sheet1','sheet2',…]`
- polars_xml 級別：`[polars_xml] sheet i name='…' cells=N nonempty=M` 與 `sample: A1->'…', B2->123, …`
- 映射：`[map] ws_index=i ws_title='…' -> key='…' provided=P keys=[…]`
- Phase 2：`[phase2] provided_from_value_engine total=X per_sheet={'sheet1':P1, …}`
- 回退：`[fallback->polars_xml] reason=polars_nonempty=0`
- 異常：`[read_error] sheet='…' addr='…' op='assemble' err=…` 或 `op='iterate_rows'`

---

## 4. 相容性與保證範圍
- 一般 .xlsx/.xlsm 檔案：
  - 能取得每張表的值（地址->值）與公式（地址->公式字串），並在比較時以 cached_value/值對齊。
  - 外部參照格式化：把 `[n]Sheet!` 轉為 `'\\path\\[Book.xlsx]Sheet'!` 這種可讀前綴（以利人看）。
- 已知兼容行為：
  - `xlsx2csv --list-sheets` 在你環境 rc=2；系統自動用 `-s i` 逐張抓取，不影響功能。
  - EmptyCell（無 coordinate）的情形已由索引推導地址方式避免早退。
- 仍需注意：
  - `polars_xml/xml` 路徑讀到的數值是 cached/raw 值，未套用 Excel 樣式（如日期/千分位）格式化；但做差異比對時，因基準線與現況路徑一致，仍能正確檢出變更。
  - 合併儲存格、表格（structured reference）、動態陣列（spill）等特殊情況已能讀公式與值，但若需 100% 重現 Excel UI 顯示格式，未來可引入樣式/格式解析（styles.xml）。

---

## 5. 即時比較與輪詢（已依你要求修正）
- on_modified 偵測到變更就「立即顯示一次比較表」，然後再進入冷靜期與輪詢。
- 若同一檔案已在輪詢中，本輪只顯示一次即時比較表（避免刷屏）。
- 這段邏輯已在程式內加上清晰註解，避免日後被不小心改壞。

---

## 6. 測試指引（值引擎驗證）
1) 在 UI 將「值讀取引擎」設為 `polars_xml`（避免 runtime 把它覆蓋回 `polars`）。
2) 跑一個曾經 READ_ERROR 的檔案，貼以下 log：
   - `[env]`、`[value-engine]`、`[polars_xml]`（cells/nonempty/sample）
   - `[map]`（provided + keys）
   - `[phase2]`（total/per_sheet）
   - 若有 `[read_error]` 行，附 err 詳情。
3) 切回 `polars` 測一次，比對 `[polars-xlsx2csv]` 與 `[fallback brute-force]`，並確認若 provided=0 則會有 `[fallback->polars_xml]`。

---

## 7. 待辦清單（下一步）
- [可選] 在 `polars_xml` 路徑也輸出「合併 CSV」（sheet,address,value），與 polars 路徑一致，便於外部分析。
- [可選] 新增設定開關：`SHOW_IMMEDIATE_COMPARE_DURING_POLLING`（目前行為為開）。
- [效能] 規劃 `MAX_SHEET_WORKERS` 併發讀表（目前為序列），大型工作簿可加速。
- [格式] 若需與 Excel UI 完全一致的顯示值，導入 `styles.xml` 的格式碼轉換（日期/時間/百分比等）。
- [覆蓋] 擴大外部參照解析（更多 edge cases 與各種路徑型態），並新增測試集。
- [診斷] polars 路徑也補充 sample（目前 polars_xml 已提供 sample 行）。

---

## 8. FAQ
- Q：看到 `[polars-xlsx2csv] fallback brute-force by index 1..N` 是不是錯？
  - A：不是。這是 `--list-sheets` 不相容時的正常替代做法（逐張抓取），屬於設計中的快路徑。
- Q：是否「絕對」可掌握每個檔案的公式和值？
  - A：在一般情況下可以穩定掌握；特殊格式（樣式呈現、極端合併/spill/自定格式）仍可讀到原始/快取值與公式，但若要完全復刻 UI 呈現，還需格式轉換支持。為比對與偵測變更的目的，現行邏輯已足夠。

---

## 9. 歷史快照（長期保存）計畫
- 目前：
  - 權威保存為「基準線壓縮檔」：包含每格 formula/value/cached_value，但每次比較（若啟用自動更新）會覆寫為最新狀態，並不保存多個歷史版本。
  - 另外有「變更 CSV（gz）」記錄有意義變更的摘要（帶時間戳），但不是完整快照。
- 需求（你提出）：
  - 需要可回溯到任意時間點的「完整內容快照」，以便事後審核與責任追蹤。
- 建議方案（下次實作）：
  1) 新增 History Snapshot：在每次顯示比較表後，將 current_data 以壓縮檔保存到
     LOG_FOLDER/history/<base_key>/<timestamp>.cells.json.zst（或 lz4），內容與基準線 cells 結構一致。
  2) 新增索引：維護一個 LOG_FOLDER/history/<base_key>/index.csv.gz，記錄時間戳、hash、最後作者、事件編號、快照檔名。
  3) 保留策略：可設定保存天數或最大版本數（例如保留 90 天或 500 版），定期清理。
  4) UI/設定開關：ENABLE_HISTORY_SNAPSHOT=True/False；HISTORY_RETENTION_DAYS；HISTORY_MAX_VERSIONS。
  5) 查詢工具：提供一個小腳本或 UI 下拉，列出某檔案的時間軸版本，點選即可載入並渲染比較表。
- 影響評估：
  - 儲存空間：每次比較產生一份完整快照（壓縮後），需控管保留策略；變更 CSV 體積極小，可長期保存。
  - 效能：寫入壓縮檔的成本可接受；如需，採用非同步寫入避免阻塞主線程。

---

（完）
